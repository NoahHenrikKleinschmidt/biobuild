import numpy as np
import scipy.optimize as opt
from typing import Union


def scipy_optimize(
    env,
    steps: int = 1e5,
    method: str = "L-BFGS-B",
    **kws,
):
    """
    Optimize a Rotatron environment through
    a simple scipy optimization

    Parameters
    ----------
    env : biobuild.optimizers.environments.Rotatron
        The environment to optimize
    steps : int, optional
        The number of steps to take, by default 1e5
    method : str, optional
        The optimizer to use, by default "L-BFGS-B".
        This can be any optimizer from scipy.optimize.minimize
    kws : dict, optional
        Keyword arguments to pass as options to the optimizer

    Returns
    -------
    tuple or Molecule
        If molecule is None, a tuple of the optimized action and the evaluation for the optimized action.
        If molecule is not None, the optimized molecule.
    """

    x0 = env.action_space.sample()

    def loss_fn(x):
        state, _eval, *_ = env.step(x)
        env.reset()
        return _eval

    if "bounds" in kws:
        bounds = kws.pop("bounds")
    elif hasattr(env, "_bounds_tuple"):
        bounds = opt.Bounds(*env._bounds_tuple)
    else:
        bounds = None

    kws["maxiter"] = int(steps)
    result = opt.minimize(loss_fn, x0, method=method, bounds=bounds, options=kws)
    return (
        result.x,
        result.fun,
    )


def genetic_optimize(
    env,
    max_generations: int = 1e3,
    stop_if_done: bool = True,
    threshold: float = 1e-4,
    variation: float = 0.3,
    population_size: int = 20,
    parents: Union[int, float] = 0.25,
    children: Union[int, float] = 0.5,
    mutants: Union[int, float] = 0.2,
    newcomers: Union[int, float] = 0.05,
    n_best: int = 1,
):
    """
    A simple genetic algorithm for optimizing a Rotatron environment.

    Parameters
    ----------
    env : biobuild.optimizers.environments.Rotatron
        The environment to optimize
    max_generations : int, optional
        The maximum number of steps to take.
    stop_if_done : bool, optional
        Stop the optimization if the environment signals it is done or the solutions have converged.
    threshold : float, optional
        A thershold to use for convergence of the best solution found.
        The algorithm will stop if the variation of the best solution evaluation history
        is less than this threshold.
    variation : float, optional
        The variation to use for the initial action.
    population_size : int, optional
        The size of the population.
    parents : int or float, optional
        The number or fraction of parents (elites) to select. The parents are selected from the best solutions. Parents produce offspring and pass to the next generation.
    children : int or float, optional
        The number or fraction of children to generate from the parents. Children are generated by averaging the parents and adding some noise.
    mutants : int or float, optional
        The number or fraction of mutants to generate. Mutants are generated by adding noise to parents, therby
        generating abarrent clones.
    newcomers: int or float, optional
        Newcomers are entirely new solution candidates.
    n_best : int, optional
        The number of best solutions to return at the end of the optimization.

    Returns
    -------
    solution, evaluation
        The angles(s) and evaluation(s) of the best solution(s) found.
    """
    if isinstance(parents, float):
        parents = round(parents * population_size)
    if isinstance(children, float):
        children = round(children * population_size)
    if isinstance(mutants, float):
        mutants = round(mutants * population_size)
    if isinstance(newcomers, float):
        newcomers = round(newcomers * population_size)

    if children + mutants + parents + newcomers != population_size:
        raise ValueError(
            "The sum of n_children, n_mutations, n_parents, and n_newcomers must equal population_size"
        )

    if any([n < 0 for n in [children, mutants, parents, newcomers]]):
        raise ValueError(
            "n_children, n_mutations, n_parents, and n_newcomers must all be at least 0"
        )

    n_parents = parents
    n_children = children
    n_mutants = mutants
    n_newcomers = newcomers

    blank = env.blank()
    population = np.stack([blank] * population_size)
    evals = np.zeros(population_size)

    bests = np.zeros(max(10, int(max_generations * 0.05)))

    pop_range = np.arange(0, population_size)
    parents_range = np.arange(0, n_parents)
    children_range = np.arange(0, n_children)
    mutations_range = np.arange(0, n_mutants)
    newcomers_range = np.arange(0, n_newcomers)

    for i in pop_range:
        population[i] = env.action_space.sample()
        _, evals[i], *_ = env.step(population[i])
        env.reset()

    steps = 0
    while steps < max_generations:
        sorting = np.argsort(evals)
        parents = population[sorting[:n_parents]]

        children = np.stack([blank] * n_children)
        for i in children_range:
            p1, p2 = np.random.choice(parents_range, size=2, replace=False)
            p1, p2 = parents[int(p1)], parents[int(p2)]
            children[i] = (p1 + p2) / 2 + np.random.normal(
                0, variation / 2, size=blank.shape
            )

        mutations = np.stack([blank] * n_mutants)
        for i in mutations_range:
            mutations[i] = parents[np.random.randint(0, n_parents)] + np.random.normal(
                0, variation, size=blank.shape
            )

        newcomers = np.stack([blank] * n_newcomers)
        for i in newcomers_range:
            newcomers[i] = env.action_space.sample()

        population = np.concatenate([parents, children, mutations, newcomers])
        evals = np.zeros(population_size)

        for i in pop_range:
            _, evals[i], done, *_ = env.step(population[i])
            env.reset(best=True)  # (see comment below)
            if done and stop_if_done:
                break

        if done and stop_if_done:
            break

        # -------------------------------------------------------------------------------------
        # Generally I think this should not be here, however
        # the very fact that the algorithm was running for 20min+
        # for some setups, shows that this probably does not affect
        # the results too much. A way of assuring this would be fine, is to also reset the best
        # evaluation when resetting the environment...
        bests = np.roll(bests, -1)
        bests[-1] = env._best_eval
        if stop_if_done and np.var(bests) < threshold:
            break
        # -------------------------------------------------------------------------------------

        steps += 1

    best = np.argsort(evals)[:n_best]
    return population[best], evals[best]


def swarm_optimize(
    env,
    n_particles: int = 10,
    max_steps: int = 30,
    stop_if_done: bool = True,
    threshold: float = 1e-5,
    variation: float = 0.1,
    recycle: float = 0.3,
    recycle_every: int = 5,
):
    """
    Optimize a rotatron environment through a simple particle swarm optimization.

    Parameters
    ----------
    env : biobuild.optimizers.environments.Rotatron
        The environment to optimize
    n_particles : int, optional
        The number of particles to use.
    max_steps : int, optional
        The maximum number of steps to take.
    stop_if_done : bool, optional
        Stop the optimization if the environment signals it is done or the solutions have converged.
    threshold : float, optional
        A threshold to use for convergence of the best solution found.
        The algorithm will stop if the variation of the best solution evaluation history
        is less than this threshold.
    variation : float, optional
        The variation to use for updating particle positions.
    recycle : float, optional
        The fraction of particles to replace by variations of the best particle when updating the particle positions.
        This will remove the worst particles and replace them with the best particle + some noise.
    recycle_every : int, optional
        The number of steps to take before recycling particles.

    Returns
    -------
    solution, evaluation
        The solution and evaluation for the solution
    """
    blank = env.blank()
    particles = np.stack([blank] * n_particles)
    velocities = np.stack([blank] * n_particles)
    evals = np.zeros(n_particles)
    n_recycle = int(n_particles * recycle)

    particle_range = np.arange(0, n_particles)
    for i in particle_range:
        particles[i] = env.action_space.sample()
        _, evals[i], *_ = env.step(particles[i])
        env.reset()

    best = np.argmin(evals)
    best_eval = evals[best]
    best_solution = particles[best]

    steps = 0
    while steps < max_steps:
        for i in particle_range:
            velocities[i] += np.random.normal(0, variation, size=blank.shape)
            velocities[i] *= 0.9
            particles[i] += velocities[i]
            _, evals[i], *_ = env.step(particles[i])
            env.reset()
            if evals[i] < best_eval:
                best_eval = evals[i]
                best_solution = particles[i]

        if steps % recycle_every == 0:
            # remove the worst particles
            # and replace them with the best particle+noise
            particles[np.argsort(evals)[n_recycle:]] = best_solution + np.random.normal(
                0, variation, size=blank.shape
            )

        if stop_if_done and env.is_done():
            break

        if stop_if_done and np.var(evals) < threshold:
            break

        steps += 1

    return best_solution, best_eval


# -------------------------------------------------------------------------------------
# This is the original code for swarm_optimize using pyswarms.
# This used to work really well with the old implementations of Rotatron.
# However, it seems to be not adapting well to the new Rotatron so I decided
# to switch to the barebone implementation in numpy alone above.
# -------------------------------------------------------------------------------------
# import pyswarms as ps
# def swarm_optimize(
#     env,
#     steps: int = 30,
#     n: int = 10,
#     molecule: "Molecule" = None,
#     bounds=(-np.pi, np.pi),
#     **kws,
# ):
#     """
#     Optimize a Rotatron environment through
#     a pyswarms swarm optimization

#     Parameters
#     ----------
#     env : biobuild.optimizers.environments.Rotatron
#         The environment to optimize
#     steps : int, optional
#         The number of steps to take, by default 1000
#     n : int, optional
#         The number of particles to use, by default 10
#     molecule : Molecule, optional
#         A molecule to apply the optimized solution to directly.
#         If None, the solution is returned, by default None. The solution is
#         applied in-place to the molecule directly.
#     bounds : tuple, optional
#         The bounds to use for solutions as a tuple of size 2 with a minimal and maximal angle to allow.
#     kws : dict, optional
#         Keyword arguments to pass as options to the optimizer

#     Returns
#     -------
#     tuple or Molecule
#         If molecule is None, a tuple of the optimized action and the reward for the optimized action.
#         If molecule is not None, the optimized molecule.
#     """

#     x0 = env.action_space.sample()

#     if bounds:
#         bounds = (np.full(x0.shape, bounds[0]), np.full(x0.shape, bounds[1]))

#     def loss_fn(sol):
#         costs = np.zeros(n)
#         i = 0
#         for s in sol:
#             costs[i] = env.step(s)[1]
#             i += 1
#         return costs

#     options = kws.pop("options", {})
#     options.setdefault("c1", 0.5)
#     options.setdefault("c2", 0.3)
#     options.setdefault("w", 0.9)

#     verbose = kws.pop("verbose", False)

#     optimizer = ps.single.GlobalBestPSO(
#         n_particles=n, dimensions=x0.shape[0], bounds=bounds, options=options, **kws
#     )
#     reward, result = optimizer.optimize(loss_fn, iters=steps, verbose=verbose)
#     if molecule:
#         molecule = outils.apply_solution(result, env, molecule)
#         return molecule
#     return result, reward

__all__ = [
    "swarm_optimize",
    "genetic_optimize",
    "scipy_optimize",
]
